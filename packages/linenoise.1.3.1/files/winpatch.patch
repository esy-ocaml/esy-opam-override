--- ./src/linenoise_src.c
+++ ./src/linenoise_src.c
@@ -100,7 +100,7 @@
  *
  */
 
-#include <termios.h>
+/* #include <termios.h> */
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -110,7 +110,7 @@
 #include <ctype.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/ioctl.h>
+/* #include <sys/ioctl.h> */
 #include <unistd.h>
 #include "linenoise_src.h"
 
@@ -121,7 +121,7 @@
 static linenoiseHintsCallback *hintsCallback = NULL;
 static linenoiseFreeHintsCallback *freeHintsCallback = NULL;
 
-static struct termios orig_termios; /* In order to restore at exit.*/
+/* static struct termios orig_termios; /\* In order to restore at exit.*\/ */
 static int rawmode = 0; /* For atexit() function to check if restore is needed*/
 static int mlmode = 0;  /* Multi line mode. Default is single line. */
 static int atexit_registered = 0; /* Register atexit just 1 time. */
@@ -216,47 +216,47 @@
     return 0;
 }
 
-/* Raw mode: 1960 magic shit. */
-static int enableRawMode(int fd) {
-    struct termios raw;
-
-    if (!isatty(STDIN_FILENO)) goto fatal;
-    if (!atexit_registered) {
-        atexit(linenoiseAtExit);
-        atexit_registered = 1;
-    }
-    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;
-
-    raw = orig_termios;  /* modify the original mode */
-    /* input modes: no break, no CR to NL, no parity check, no strip char,
-     * no start/stop output control. */
-    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
-    /* output modes - disable post processing */
-    raw.c_oflag &= ~(OPOST);
-    /* control modes - set 8 bit chars */
-    raw.c_cflag |= (CS8);
-    /* local modes - choing off, canonical off, no extended functions,
-     * no signal chars (^Z,^C) */
-    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
-    /* control chars - set return condition: min number of bytes and timer.
-     * We want read to return every single byte, without timeout. */
-    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
-
-    /* put terminal in raw mode after flushing */
-    if (tcsetattr(fd,TCSADRAIN,&raw) < 0) goto fatal;
-    rawmode = 1;
-    return 0;
-
-fatal:
-    errno = ENOTTY;
-    return -1;
-}
-
-static void disableRawMode(int fd) {
-    /* Don't even check the return value as it's too late. */
-    if (rawmode && tcsetattr(fd,TCSADRAIN,&orig_termios) != -1)
-        rawmode = 0;
-}
+/* /\* Raw mode: 1960 magic shit. *\/ */
+/* static int enableRawMode(int fd) { */
+/*     struct termios raw; */
+
+/*     if (!isatty(STDIN_FILENO)) goto fatal; */
+/*     if (!atexit_registered) { */
+/*         atexit(linenoiseAtExit); */
+/*         atexit_registered = 1; */
+/*     } */
+/*     if (tcgetattr(fd,&orig_termios) == -1) goto fatal; */
+
+/*     raw = orig_termios;  /\* modify the original mode *\/ */
+/*     /\* input modes: no break, no CR to NL, no parity check, no strip char, */
+/*      * no start/stop output control. *\/ */
+/*     raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON); */
+/*     /\* output modes - disable post processing *\/ */
+/*     raw.c_oflag &= ~(OPOST); */
+/*     /\* control modes - set 8 bit chars *\/ */
+/*     raw.c_cflag |= (CS8); */
+/*     /\* local modes - choing off, canonical off, no extended functions, */
+/*      * no signal chars (^Z,^C) *\/ */
+/*     raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG); */
+/*     /\* control chars - set return condition: min number of bytes and timer. */
+/*      * We want read to return every single byte, without timeout. *\/ */
+/*     raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /\* 1 byte, no timer *\/ */
+
+/*     /\* put terminal in raw mode after flushing *\/ */
+/*     if (tcsetattr(fd,TCSADRAIN,&raw) < 0) goto fatal; */
+/*     rawmode = 1; */
+/*     return 0; */
+
+/* fatal: */
+/*     errno = ENOTTY; */
+/*     return -1; */
+/* } */
+
+/* static void disableRawMode(int fd) { */
+/*     /\* Don't even check the return value as it's too late. *\/ */
+/*     if (rawmode && tcsetattr(fd,TCSADRAIN,&orig_termios) != -1) */
+/*         rawmode = 0; */
+/* } */
 
 /* Use the ESC [6n escape sequence to query the horizontal cursor position
  * and return it. On error -1 is returned, on success the position of the
@@ -283,40 +283,40 @@
     return cols;
 }
 
-/* Try to get the number of columns in the current terminal, or assume 80
- * if it fails. */
-static int getColumns(int ifd, int ofd) {
-    struct winsize ws;
-
-    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
-        /* ioctl() failed. Try to query the terminal itself. */
-        int start, cols;
-
-        /* Get the initial position so we can restore it later. */
-        start = getCursorPosition(ifd,ofd);
-        if (start == -1) goto failed;
-
-        /* Go to right margin and get position. */
-        if (write(ofd,"\x1b[999C",6) != 6) goto failed;
-        cols = getCursorPosition(ifd,ofd);
-        if (cols == -1) goto failed;
-
-        /* Restore position. */
-        if (cols > start) {
-            char seq[32];
-            snprintf(seq,32,"\x1b[%dD",cols-start);
-            if (write(ofd,seq,strlen(seq)) == -1) {
-                /* Can't recover... */
-            }
-        }
-        return cols;
-    } else {
-        return ws.ws_col;
-    }
-
-failed:
-    return 80;
-}
+/* /\* Try to get the number of columns in the current terminal, or assume 80 */
+/*  * if it fails. *\/ */
+/* static int getColumns(int ifd, int ofd) { */
+/*     struct winsize ws; */
+
+/*     if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) { */
+/*         /\* ioctl() failed. Try to query the terminal itself. *\/ */
+/*         int start, cols; */
+
+/*         /\* Get the initial position so we can restore it later. *\/ */
+/*         start = getCursorPosition(ifd,ofd); */
+/*         if (start == -1) goto failed; */
+
+/*         /\* Go to right margin and get position. *\/ */
+/*         if (write(ofd,"\x1b[999C",6) != 6) goto failed; */
+/*         cols = getCursorPosition(ifd,ofd); */
+/*         if (cols == -1) goto failed; */
+
+/*         /\* Restore position. *\/ */
+/*         if (cols > start) { */
+/*             char seq[32]; */
+/*             snprintf(seq,32,"\x1b[%dD",cols-start); */
+/*             if (write(ofd,seq,strlen(seq)) == -1) { */
+/*                 /\* Can't recover... *\/ */
+/*             } */
+/*         } */
+/*         return cols; */
+/*     } else { */
+/*         return ws.ws_col; */
+/*     } */
+
+/* failed: */
+/*     return 80; */
+/* } */
 
 /* Clear the screen. Used to handle ctrl+l */
 void linenoiseClearScreen(void) {

